using System.Reflection;
using System;
using System.Text;
using System.Diagnostics;
namespace NSLS {
	class Tracer {

		/* The following were generated by a code-snippet:
		* internal log(MethodBase),
		* internal log(MethodBase,string,params object[]),
		* internal log(MethodBase,Exception),
		* internal log(MethodBase,Exception,string,params object[]),
		* internal log(string,params object[]),
		* internal log(string),
		* string methodSignature(MethodBase) and
		* string decomposeException(Exception).
		*
		* Add the following BEFORE expanding this snippet:
		* using System;
		* using System.Text;
		* using System.Reflection;
		* using System.Diagnostics;
		*/

		#region fields
		/// <summary>
		/// log messages to the console.
		/// </summary>
		///
		/// <seealso cref="logToConsole"/>
		static bool _logToConsole=false;

		static bool _showParms=false;
		#endregion fields

		#region properties
		/// <summary>
		/// log messages to the console.
		/// </summary>
		///
		/// <value>
		/// <para>
		/// Exposes the <see cref="_logToConsole"/> field.
		/// </para>
		///
		/// <para>
		/// Used by <see cref="log(string)"/>.
		/// </para>
		/// </value>
		///
		/// <seealso cref="_logToConsole"/>
		/// <seealso cref="log(string)"/>
		public static bool logToConsole {
			get { return _logToConsole; }
			set { _logToConsole=value; }
		}

		/// <summary>
		/// Add parameter information when generating method signatures.
		/// </summary>
		/// 
		/// <value>This property exposes the <see cref="_showParms"/> field.</value>
		/// 
		/// <remarks>
		/// This property is used in <see cref="methodSignature(MethodBase)"/>.
		/// </remarks>
		/// 
		/// <seealso cref="_showParms"/>
		/// <seealso cref="methodSignature(MethodBase)"/>
		public static bool showParameters {
			get { return _showParms; }
			set { _showParms=value; }
		}
		#endregion properties

		#region logging methods
		/// <summary>
		/// log execution of a method.
		/// </summary>
		///
		/// <param name="mb">
		/// a <see cref="MethodBase"/> from which to extract the class-info.
		/// </param>
		///
		/// <remarks>
		/// This overload provides a complete list of parameters to differentiate
		/// constructors and methods.
		/// </remarks>
		///
		/// <seealso cref="methodSignature(MethodBase)"/>
		/// <seealso cref="log(string)"/>
		/// <seealso cref="Trace"/>
		///
		internal static void log(MethodBase mb) {
			log(methodSignature(mb));
		}

		/// <summary>
		/// log a message from a given method, given a format-string an 
		/// vector of arguments.
		/// </summary>
		///
		/// <param name="mb">
		/// a <see cref="MethodBase"/> from which to extract the class-info.
		/// </param>
		///
		/// <param name="szFmt2">
		/// a <see cref="string"/> to use as the format-string.
		/// </param>
		///
		/// <param name="args">
		/// an optional <see cref="Array"/> of <see cref="object"/>s to format.
		/// </param>
		///
		/// <seealso cref="methodSignature(MethodBase)"/>
		/// <seealso cref="log(string)"/>
		/// <seealso cref="Trace"/>
		///
		internal static void log(MethodBase mb,string szFmt2,params object[] args) {
			log(string.Format("{0} : {1}",
			methodSignature(mb),
			string.Format(szFmt2,args)));
		}

		/// <summary>
		/// log where a given <see cref="Exception"/> occurred.
		/// </summary>
		///
		/// <param name="mb">
		/// a <see cref="MethodBase"/> from which to extract the class-info.
		///</param>
		///
		/// <param name="ex">
		/// a <see cref="Exception"/> containing exception-information to display./// </param>
		///
		/// <seealso cref="methodSignature(MethodBase)"/>
		/// <seealso cref="log(string)"/>
		/// <seealso cref="Trace"/>
		/// <seealso cref="decomposeException(Exception)"/>
		///
		internal static void log(MethodBase mb,Exception ex) {
			log(string.Format("{0}:{1}",
			methodSignature(mb),
			string.Format("{0}\r\n{1}",decomposeException(ex),ex.StackTrace)));
		}

		/// <summary>
		/// log where a given <see cref="Exception"/> occurred with 
		/// a custom message.
		/// </summary>
		///
		/// <param name="mb">
		/// a <see cref="MethodBase"/> from which to extract the class-info.
		/// </param>
		///
		/// <param name="ex">
		/// a <see cref="Exception"/> containing exception-information to display.
		/// </param>
		///
		/// <param name="szFmt2">
		/// a <see cref="string"/> containing the (formattable) custom-message.
		/// </param>
		///
		/// <param name="args">
		/// an <see cref="Array"/> of <see cref="object"/>s to be inserted into <paramref name="szFmt2"/>.
		/// </param>
		///
		/// <seealso cref="log(string)"/>
		/// <seealso cref="decomposeException(Exception)"/>
		/// <seealso cref="Trace"/>
		internal static void log(MethodBase mb,Exception ex,string szFmt2,params object[] args) {
			log(string.Format("{0}:{1}\r\n{2}",
			methodSignature(mb),
			string.Format(szFmt2,args),
			string.Format("{0}\r\n{1}",decomposeException(ex),ex.StackTrace)));
		}

		/// <summary>
		/// log a formatted message.
		/// </summary>
		///
		/// <param name="szFmt2">
		/// a <see cref="string"/> to be used for formatting <paramref name="args"/>.
		/// </param>
		/// 
		/// <param name="args">
		/// an <see cref="Array"/> of <see cref="object"/>s to be inserted into <paramref name="szFmt2"/>.
		/// </param>
		///
		/// <seealso cref="log(string)"/>
		internal static void log(string szFmt2,params object[] args) {
			log(string.Format(szFmt2,args));
		}

		/// <summary>
		/// a generic method to log szMsg to either <see cref="Console.Error"/> or
		/// </summary>
		///
		/// <param name="szMsg">a <see cref="string"/> to display.</param>
		///
		/// <remarks>
		/// the <see cref="string"/> is generated to either <b>Console</b> or
		/// <b>Trace</b> depending on the preprocesor symbol <b><i>TRACE</i></b>.
		/// </remarks>
		///
		/// <seealso cref="Trace"/>
		internal static void log(string szMsg) {
#if TRACE
			Trace.WriteLine(string.Format("[TRACE] : {0}",szMsg));
#else
	Console.Error.WriteLine("[ERROR] : {0}",szMsg);
#endif
			if (logToConsole)
				Console.WriteLine("[CONSOLE] : {0}",szMsg);
		}
		#endregion logging methods

		#region log-utility methods
		/// <summary>
		/// Generate a complete message.
		/// </summary>
		public static string logMessage(MethodBase mb,Exception ex) {
			return string.Format("{0}:{1}",
				methodSignature(mb),
				string.Format("{0}\r\n{1}",decomposeException(ex),ex.StackTrace));
		}

		/// <summary>
		/// Generate a method signature.
		/// </summary>
		///
		/// <returns>
		/// a <see cref="string"/> containing the method signature, or
		/// <see cref="string.Empty"/> if <paramref name="mb"/> is null.
		/// </returns>
		///
		/// <remarks>
		/// <para>
		/// Generates the signature  and it's parameters, based upon 
		/// the value of <see cref="showParameters"/>.
		/// </para>
		/// <para>
		/// This method uses a <see cref="StringBuilder"/> to generate the 
		/// resultant <see cref="string"/>.
		/// </para>
		/// </remarks>
		///
		/// <seealso cref="showParameters"/>
		/// <seealso cref="MethodBase"/>
		/// <seealso cref="StringBuilder"/>
		static string methodSignature(MethodBase mb) {
			int n;
			bool bCTOR;
			ParameterInfo[] pis;
			ParameterInfo pi;
			StringBuilder sb;

			if (mb!=null) {
				sb=new StringBuilder();
				bCTOR=mb.IsConstructor||mb.Name==".cctor";

				if (mb.ReflectedType!=null)
					sb.AppendFormat(bCTOR?"{0}{1}":"{0}.{1}",
						mb.ReflectedType.Name,
						mb.Name);
				else
					sb.Append(mb.Name);
				if (showParameters) {
					pis=mb.GetParameters();
					sb.Append('(');
					if (pis!=null && (n=pis.Length)>0) {
						for (int i=0;i<n;i++) {
							if (i>0)
								sb.Append(',');
							pi=pis[i];
							sb.AppendFormat("{0} {1}",pi.ParameterType.Name,pi.Name);
						}
					}
					sb.Append(')');
				}
				return sb.ToString();
			}
			return "null";
		}

		/// <summary>
		/// Recursively descend an exception, extracting types and messages.
		/// </summary>
		///
		/// <param name="ex"> an <see cref="Exception"/> to descend.</param>
		///
		/// <returns>
		/// a <see cref="string"/> containing the exception hierarchy
		/// for <paramref name="ex"/> or <see cref="string.Empty"/>.
		/// </returns>
		///
		/// <remarks>
		/// This method iterates through the top-level exception <paramref name="ex"/>
		/// and it's <see cref="Exception.InnerException"/>'s in order to populate the
		/// returned <see cref="string"/>.
		/// </remarks>
		static string decomposeException(Exception ex) {
			StringBuilder sb;
			Exception cex;

			if (ex==null) return string.Empty;

			sb=new StringBuilder();
			cex=ex;
			while (cex!=null) {
				sb.Append("\r\n\t");
				sb.AppendFormat("{0}: {1}",cex.GetType().Name,cex.Message);
				cex=cex.InnerException;
			}
			return sb.ToString();
		}
		#endregion log-utility methods

	}
}